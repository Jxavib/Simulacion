---
title: "Practica 3"
author: "Beltran Henry, Burbano Joel, Guaman Ronny"
date: "1/7/2021"
output: 
  html_document: 
    theme: cerulean
    highlight: zenburn
---
# Métodos Universales para la simulación de variables discretas

***6. Se pretende simular valores de una distribución $Bi(10,0.5)$. Para ello***

  ***a) Generar por el método de la transformación cuantil usando busqueda secuencial, una muestra de $nsim=10^5$ observaciones de esta variable. Obtener el tiempo de CPU empleado. Aproximar por simulación la función de masa de probabilidad,  representarla gráficamente y compararla con la teórica. Calcular también la media muestral (compararla con la teórica $np$) y el número medio de comparaciones para generar cada observación.***
  
```{r message=FALSE, warning=FALSE}
# Implementamos el algoritmo de transformación cuantil con busqueda sequencial.


rfmp <- function(x,prob=1/length(x),nsim=1000){
  Fx <- cumsum(prob)
  # simular
  X <- numeric(nsim)  #creamos un vector de indices
  U <- runif(nsim)   #creamos un vector de probilidad uniforme
  ncomp <- 0 
  for(j in 1:nsim){
    i <- 1
    while(Fx[i]<U[j]) i <- i+1
    X[j] <- x[i]
    ncomp<<-ncomp+ i
  }
  return(X)
}
```

Ahora empleando la rutina anterior generamos las simulaciones:

```{r}
set.seed(54321)
n <- 10
p <- 0.5
nsim <- 10^5
x <- 0:n   # crea un arreglo de n+1 componentes 0,1,2,..
fmp <- dbinom(x,n,p) # crea un arreglo de la funcion de mas de probabilidad
ncomp <- 0  # regresa el valor de ncomp a 0
system.time(rx <- rfmp(x,fmp,nsim)) # calcula el tiempo en sgundos que toma ejecutar una expresion(en este caso rfmp)

```

Aproximación de la media 

```{r}
mean(rx)
```

El valor teórico es $n*p=5$

La presición que se ha obtenido es 

```{r}
abs(mean(rx)-n*p)
```

Número medio de comparaciones:

```{r}
ncomp/nsim
```

Analisís de los resultados 

```{r}
res <- table(rx)/nsim    # crea una tabla con lo elementos de rx y los divide para nsim
plot(res, ylab="frequencia relatica", xlab="valores") #grafica los valores simulados
points(x,fmp,pch=4,col='blue') #grafica los valores teoricos
```

```{r}
res <- as.data.frame(res) # mutamos res a un data frame
names(res) <- c('x','psim')  #asignamos nombres a las columnas del data frame
res$pteor <- fmp   # creamos una nueva columna a la cual le asiganamos los valores de fmp
res
```

Ahora vemos que sucede con los errores

Error absoluto

```{r}
max(abs(res$psim-res$pteor))
```

Error Relativo

```{r}
max(abs(res$psim-res$pteor) /res$pteor)
```

```{r include=F}
# NOTA: Puede ocurrir que no todos los valores sean generados en la simulación
# Si length(x) > length(psim) el código anterior (res$pteor <- fmp) producirá un error
# Alternativamente:
psim <- rep(0, length(x))
names(psim) <- as.character(x)
psim[as.character(res$x)] <- res$psim
psim
res <- data.frame(x=x, pteor=fmp, psim =psim)
res

```

  ***b) Repetir el apartado anterior ordenando previamente las probabilidades en orden decreciente y tambien empleando la función sample de*** ``R``
  
```{r}
tini <- proc.time()  # permite obtener tiempo de computacion real y de CPU

ncomp <- 0  # regresamos a 0 el valor de ncomp
ind <- order(fmp,decreasing = T)   #creamos un vector de indices de fmp ordenada de manera decrciente
rx <- rfmp(x[ind],fmp[ind],nsim) # llamamos a la funcion rfmp

tiempo <- proc.time()-tini
tiempo 
```

Numero de comparaciones 

```{r}
ncomp/nsim
```

Valor teorico

```{r}
sum((1:length(x))*fmp[ind])
```

Empleando la función ``sample(x)``

```{r}
system.time(rx <- sample(x,nsim,replace = T,prob = fmp))
```

```{r include=F}
# -------------------------------
# Si n >> 30
# Aproximación normal con corrección continuidad
mean <- n*p
sd <- sqrt(n*p*(1-p))

res$pnorm <- pnorm(x+0.5,mean,sd)-pnorm(x-0.5,mean,sd)
res
max(abs(res$pnorm - res$pteor))
max(abs(res$pnorm - res$pteor) / res$pteor)

system.time(
rx <- pmax(0, pmin(n, round( rnorm(nsim, mean, sd) )))
)

table(rx)/nsim
```

```{r include=F}
# Realmente las prob de los extremos serían mayores...
res$pnorm[1] <- pnorm(0.5, mean, sd)
res$pnorm[n+1] <- 1 - pnorm(n-0.5, mean, sd)
```

  ***c) Diseñar una rutina que permita generar $nsim$ valores de una distribución discreta usando una tabla guía. Repetir los pasos de los apartados anteriores empleando esta rutina (con $m=n-1$). Comparar los resultados obtenidos.***

Primero se implementara el algoritmo en ``R``

```{r}
rfmp.tabla <- function(x,prob=1/length(x),m,nsim=1000){
  Fx <- cumsum(prob)
  g <- rep(1,m)  #generamos una lista de m veces 1
  i <- 1
  for(j in 2:m){
    while (Fx[i]<(j-1)/m)  i <- i+1
    g[j] <- i
  }
  X <- numeric(nsim)  #creamos un vector de indices
  U <- runif(nsim)   #creamos un vector cuyas entradas son valores de un distribucion uniforme
  for(j in 1:nsim){
    i <- g[floor(U[j]*m)+1]
    while (Fx[i]<U[j]) i <- i+1
    X[j] <- x[i]
  }
  return(X)
}
```

Tiempo de ejecución

```{r}
system.time(rx <- rfmp.tabla(x,fmp,n-1,nsim))
```

Ánalisis de los resultados:

```{r}
res <- table(rx)/nsim
plot(res, ylab = "frecuencia relativa", xlab = "valores")
points(x,fmp,pch=4,col='blue')
```

***7. Se pretende simular $nsim=10^4$ observaciones de una variable hypergeometrica (``dhyper(x,m,n,k)``) de parametros $m=$ dos últimas cifras del DNI , $n=100-m$ y $k=20$.***
  
  ***a) Generar los valores empleando el método de la tranformación cuantil usando busqueda sequencial. Obtener el tiempo de CPU empleado. Aproximar por simulación la función de masa de probabilidad, representarla graficamente y compararla con la teórica. Calcular también la media muestral (compararla con la teórica $km/(m+n)$) y el número medio de comparaciones para generar cada observación.***
  
```{r}
set.seed(54321)
m <- 46
n <- 100-m
k <- 20
nsim <- 10^4

x <- 0:n
fmp <- dhyper(x,m,n,k)

ncomp <- 0  #ponemos en 0 ncomp

system.time(hx <- rfmp(x,fmp,nsim))
```

Aproximación de la media

```{r}
mean(hx)
```

El valor teorico es $km/(m+n)$

```{r}
k*m/(m+n)
```

Número de comparaciones

```{r}
ncomp/nsim
```

Analisís de los resultados 

```{r}
res <- as.data.frame(table(hx)/nsim)
names(res) <- c("x", "psim")
plot(as.matrix(res), type="h")
points(x,fmp,pch=4,col='blue') #grafica los valores teoricos
```


```{r eval=FALSE, include=FALSE}
# 
#  Verificar este parte del codigo surje un problema como se menciona en la teoria
# 
psim <- rep(0, length(x))
names(psim) <- as.character(x)
psim[as.character(res$x)] <- res$psim
psim
res <- data.frame(x=x, pteor=fmp, psim =psim)
res
```

  ***b) Repetir el apartado anterior ordenando previamente las probabilidades en orden decreciente, tambien empleando la función ``sample()`` de ``R`` y empleando una tabla guía (con $k-1$ subintervalos)***
  
  
```{r}
tini <- proc.time()  # permite obtener tiempo de computacion real y de CPU

ncomp <- 0  # regresamos a 0 el valor de ncomp
ind <- order(fmp,decreasing = T)   #creamos un vector de indices de fmp ordenada de manera decrciente
hx <- rfmp(x[ind],fmp[ind],nsim) # llamamos a la funcion rfmp

tiempo <- proc.time()-tini
tiempo 
```

Numero de comparaciones 

```{r}
ncomp/nsim
```

Valor teorico

```{r}
sum((1:length(x))*fmp[ind])
```

Empleando la función ``sample(x)``

```{r}
system.time(hx <- sample(x,nsim,replace = T,prob = fmp))
```

Empleando una tabla guía 

Tiempo de ejecución

```{r}
system.time(hx <- rfmp.tabla(x,fmp,k-1,nsim))
```

Ánalisis de los resultados:

```{r}
res <- table(hx)/nsim
plot(res, ylab = "frecuencia relativa", xlab = "valores")
points(x,fmp,pch=4,col='blue')
```

  ***c) Diseñar una rutina que permita generar $nsim$ valores de una distribución discreta usando el método de Alias. Repetir los pasos de los apartados anteriores empleando esta rutina comparar los resultados obtenidos.***
  
Primero implementamos el algoritmo Alias en ``R``

```{r}
rfmp.alias <- function(x,prob=1/length(x),nsim=1000){
  # Inicializamos las tablas
  a <- numeric(length(x)) 
  q <- prob*length(x)
  low <- q < 1
  high <- which(!low)
  low <- which(low) 
  while (length(high) && length(low)){
    l <- low[1]
    h <- high[1]
    a[l] <- h
    q[h] <- q[h]-(1-q[l])
    if (q[h]<1){
      high <- high[-1]
      low[1] <- h
    } else low <- low[-1]
  }
  # Generación de valores
  V <- runif(nsim)
  i <- floor(runif(nsim)*length(x))+1
  return(x[ifelse(V<q[i],i,a[i])])
}
```

Tiempo de ejecución empleando Alias

```{r}
system.time(hx <- rfmp.alias(x,fmp,nsim))
```

Análisis de los resultados:

```{r}
res <- table(hx)/nsim
plot(res,ylab="frecuencia relativa", xlab = "valores")
points(x,fmp,pch=4,col='blue')
```

